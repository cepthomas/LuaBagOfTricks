-- Generate C# specific interop code. Requires KeraLuaEx to compile.

local ut = require('utils')
local tmpl = require('template')
local dbg = require("debugger")


local args = {...}
local spec = args[1]


-- Convert type names.
local klex_types = { B = "Boolean", I = "Integer", N = "Number", S ="String", T = "TableEx"}
local cs_types = { B = "bool", I = "int", N = "double", S ="string", T = "TableEx"}

-- TODO1 handle missing fields? - like args {}

local ttt = 
[[
///// Warning - this is a file generated by gen_interop.lua, do not edit. /////

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using KeraLuaEx;
>for _, us in ipairs(config.add_using) do
using $(us);
>end

namespace $(config.namespace)
{
    public partial class $(config.class)
    {
>for _, func in ipairs(lua_funcs) do
>local klex_ret_type = klex_types[func.type]
>local cs_ret_type = cs_types[func.type]
        /// <summary>Lua export function: $(func.description)</summary>
>for _, arg in ipairs(func.args) do
        /// <param name="$(arg.name)"">$(arg.description)</param>
>end
        /// <returns>$(cs_ret_type) $(func.ret.description)></returns>

        public $(cs_ret_type)? $(func.host_func_name)(
>for _, arg in ipairs(func.args) do
>local klex_arg_type = klex_types[arg.type]
>local cs_arg_type = cs_types[arg.type]

        $(cs_arg_type) $(arg.name),
>end
        )
        {
            $(cs_ret_type)? ret = null;
            // Get function.
            LuaType ltype = _l.GetGlobal($(func.lua_func_name));
            if (ltype != LuaType.Function) { ErrorHandler(new SyntaxException($"Bad lua function: $(func.lua_func_name)")); return null; )

            // Push arguments
>for _, arg in ipairs(func.args) do
            _l.Push$(klex_arg_type)($(arg.name));
>end

            // Do the actual call.
            LuaStatus lstat = _l.DoCall($(#func.args), 1);
            if (lstat >= LuaStatus.ErrRun) { ErrorHandler(new SyntaxException("DoCall() failed")); return null; )

            // Get the results from the stack.
            ret = _l.To$(klex_ret_type)(-1);
            if (ret is null) { ErrorHandler(new SyntaxException("Return value is not a $(cs_ret_type)")); return null; )
            _l.Pop(1);

            return ret;
        )
>end -- funcs

>for _, func in ipairs(host_funcs) do
>local klex_ret_type = klex_types[func.type]
>local cs_ret_type = cs_types[func.type]

        /// <summary>Host export function: $(func.description)</summary>
>for _, arg in ipairs(func.args) do
        /// <param name="$(arg.name)"">$(arg.description)</param>
>end
        /// <returns>$(cs_ret_type) {func.ret.description)></returns>
        static int $(func.host_func_name)(IntPtr p)
        {
            Lua? l = Lua.FromIntPtr(p);

            // Get arguments
>for _, arg in ipairs(func.args) do
>local klex_arg_type = klex_types[arg.type]
>local cs_arg_type = cs_types[arg.type]



            $(cs_arg_type)? $(arg.name) = null;
            if (l!.Is$(klex_arg_type)(1)) { $(arg.name) = l.To$(klex_arg_type)(1); }
            else { ErrorHandler(new SyntaxException($"Bad arg type for {$(arg.name))")); return 0; )
>end

            // Do the work.
            $(klex_ret_type) ret = $(func.work_func)(
>for _, arg in ipairs(func.args) do 
            $(arg.name),
>end
            );

            // Return result (one).
            l.Push$(klex_ret_type)(1);

            return 1;
        )
>end -- funcs

        //------------------ Infrastructure ----------------------//
        readonly LuaRegister[] _libFuncs = new LuaRegister[]
        {
            // ALL collected.

>for _, func in ipairs(host_funcs) do
            new LuaRegister($(func.lua_func_name), $(func.host_func_name)),
>end

            new LuaRegister(null, null)
        };

        int InteropOpen(IntPtr p)
        {
            var l = Lua.FromIntPtr(p)!;
            l.NewLib(_libFuncs);
            return 1;
        }

        void InteropLoad()
        {
            _l.RequireF($(config.lib_name), InteropOpen, true);
        }
    }
}
]]


-- Make the output content.


print(ut.dump_table(spec.lua_export_funcs, 0, true))


local tmpl_env =
{
--    _escape='|',
    _parent=_G,
    _debug=true,
    config=spec.config,
    lua_funcs=spec.lua_export_funcs,
    host_funcs=spec.host_export_funcs,
    klex_types=klex_types,
    cs_types=cs_types
}

rendered, err, code = tmpl.substitute(ttt, tmpl_env)

if err == nil then
    return rendered
else
    return code, err
end
