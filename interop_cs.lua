-- Generate C# specific interop code. Requires KeraLuaEx to compile.

local ut = require('utils')
local tmpl = require('template')
local dbg = require("debugger")


local args = {...}
local spec = args[1]

-- Convert type names.
local klex_types = { B = "Boolean", I = "Integer", N = "Number", S ="String", T = "TableEx"}
local cs_types = { B = "bool", I = "int", N = "double", S ="string", T = "TableEx"}

-- TODOGEN handle missing fields - like args {}

local ttt = 
[[
///// Warning - this is a file generated by gen_interop.lua, do not edit. /////

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using KeraLuaEx;
|for _, us in ipairs(config.add_using) do
using $(us);
|end

namespace $(config.namespace)
{
    public partial class $(config.class)
    {
|for _, func in ipairs(lua_funcs) do
|local klex_rt = klex_types[func.type]
|local cs_rt = cs_types[func.type]
        /// <summary>Lua export function: $(func.description)</summary>
|for _, arg in ipairs(func.args) do
        /// <param name=$(arg.name)>$(arg.description)</param>
|end
        /// <returns>$(cs_rt) $(func.ret.description)></returns>

        public $(cs_rt)? $(func.host_func_name)(
|for _, arg in ipairs(func.args) do
|local klex_at = klex_types[arg.type]
|local cs_at = cs_types[arg.type]

        $(cs_at) $(arg.name),
|end
        )
        {
            $(cs_rt)? ret = null;
            // Get function.
            LuaType ltype = _l.GetGlobal($(func.lua_func_name));
            if (ltype != LuaType.Function) { ErrorHandler(new SyntaxException($"Bad lua function: $(func.lua_func_name)")); return null; )

            // Push arguments
|for _, arg in ipairs(func.args) do
            _l.Push$(klex_at)($(arg.name));
|end

            // Do the actual call.
            LuaStatus lstat = _l.DoCall($(#func.args), 1);
            if (lstat >= LuaStatus.ErrRun) { ErrorHandler(new SyntaxException("DoCall() failed")); return null; )

            // Get the results from the stack.
            ret = _l.To$(klex_rt)(-1);
            if (ret is null) { ErrorHandler(new SyntaxException("Return value is not a $(cs_rt)")); return null; )
            _l.Pop(1);

            return ret;
        )
|end -- funcs

|for _, func in ipairs(host_funcs) do
|local klex_rt = klex_types[func.type]
|local cs_rt = cs_types[func.type]

        /// <summary>Host export function: $(func.description)</summary>
|for _, arg in ipairs(func.args) do
        /// <param name=$(arg.name)>$(arg.description)</param>
|end
        /// <returns>$(cs_rt) {func.ret.description)></returns>
        static int $(func.host_func_name)(IntPtr p)
        {
            Lua? l = Lua.FromIntPtr(p);

            // Get arguments
|for _, arg in ipairs(func.args) do
|local klex_at = klex_types[arg.type]
|local cs_at = cs_types[arg.type]



            $(cs_at)? $(arg.name) = null;
            if (l!.Is$(klex_at)(1)) { $(arg.name) = l.To$(klex_at)(1); }
            else { ErrorHandler(new SyntaxException($"Bad arg type for {$(arg.name))")); return 0; )
|end

            // Do the work.
            $(klex_rt) ret = $(func.work_func)(
|for _, arg in ipairs(func.args) do 
            $(arg.name),
|end
            );

            // Return result (one).
            l.Push$(klex_rt)(1);

            return 1;
        )
|end -- funcs

        //------------------ Infrastructure ----------------------//
        readonly LuaRegister[] _libFuncs = new LuaRegister[]
        {
            // ALL collected.

|for _, func in ipairs(host_funcs) do
            new LuaRegister($(func.lua_func_name), $(func.host_func_name)),
|end

            new LuaRegister(null, null)
        };

        int InteropOpen(IntPtr p)
        {
            var l = Lua.FromIntPtr(p)!;
            l.NewLib(_libFuncs);
            return 1;
        }

        void InteropLoad()
        {
            _l.RequireF($(config.lib_name), InteropOpen, true);
        }
    }
}
]]


-- Make the output content.
local tmpl_env =
{
    _escape='|',
    _parent=_G,
    _debug=true,
    config=spec.config,
    lua_funcs=spec.lua_export_funcs,
    host_funcs=spec.host_export_funcs,
    klex_types=klex_types,
    cs_types=cs_types
}

rendered, err, code = tmpl.substitute(ttt, tmpl_env)

if err == nil then
    return rendered
else
    return code, err
end
